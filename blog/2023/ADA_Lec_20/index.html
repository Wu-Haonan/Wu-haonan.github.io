<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Rounding and Dynamic Programming:Parallel Macines Job Scheduling | Haonan Wu (吴昊楠) </title> <meta name="author" content="Haonan Wu (吴昊楠)"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%A7%AC&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://wu-haonan.github.io/blog/2023/ADA_Lec_20/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Haonan</span> Wu (吴昊楠) </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Talks and Posters </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Travelling Gallery </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Rounding and Dynamic Programming:Parallel Macines Job Scheduling</h1> <p class="post-meta"> Created on October 30, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/algorithm-design-and-analysis"> <i class="fa-solid fa-hashtag fa-sm"></i> Algorithm_Design_and_Analysis</a>   ·   <a href="/blog/category/algorithm-design-and-analysis"> <i class="fa-solid fa-tag fa-sm"></i> Algorithm_Design_and_Analysis</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>From this blog, we will talk about “rounding data” strategy and dynamic programing applied in approximation algorithm in detail. And this blog will focus on the problem “scheduling jobs on identical parallel macines”.</p> <h1 id="polynomial-time-approximation-scheme-ptas">Polynomial time approximation Scheme (PTAS)</h1> <p><b>Definition</b>: A polynomial time approximation scheme (PTAS) is a family of algorithms ${ A_{\epsilon} }$, where there is an algorithm for each ${ \epsilon \geq 0}$, such that ${ A_{\epsilon} }$ is a ${(1+\epsilon) }$-approximation algorithm (for minimization problems) or a ${(1-\epsilon) }$-approximation algorithm (for maximization problems)</p> <p>We should noticed that</p> <ol> <li> <p>Running time depends on ${ \epsilon }$, for fixing ${ \epsilon }$, the runing time is a polynomial function of ${ n }$.</p> </li> <li> <p>PTAS is stronger than other approximation, because there is no lower bound on the approximation ratio.</p> </li> </ol> <h1 id="problem-definition-and-whole-idea">Problem Definition and whole idea</h1> <h2 id="definition-of-problem">Definition of problem</h2> <p>Given ${ n }$ jobs and ${ m }$ machines each able to process one job at a time.</p> <p>Each job is associated with a process time ${ p_j }$. All jobs are available at time ${ 0 }$.</p> <p>We need to assign all the ${ n }$ jobs to ${ m }$ machines. Denote the time that job ${ j }$ is completed as ${ C_j }$.</p> <p>The objective is minimize the makespan ${ C_{max} = \max_j C_j }$.</p> <h2 id="big-picture-of-idea">Big picture of idea</h2> <ol> <li> <p>First we will split the jobs into two kinds – long jobs and short jobs. We will show <b>if</b> we can schedule these long jobs with ${ (1+\epsilon) }$-approximation, then the result is <b>still ${ (1+\epsilon) }$-approximation</b> after scheduling these short jobs.</p> </li> <li> <p>So we move to how to scheduling long jobs with ${ (1+\epsilon) }$-approximation. We can give a series time ${ T }$ and find an algorithm to <b>check if we can finish all the jobs in given time ${ T }$</b>. We select a series of ${ T }$ like ${ 1, (1+\epsilon), (1+\epsilon)^2, \cdots, (1+\epsilon)^n }$, and we find the minimum ${ T^* }$ such that we can complete all the jobs, that will guarantee ${ (1+\epsilon) }$-approximation.</p> </li> <li> <p>Now we need to find an algorithm to check if we can finish all the jobs in given time ${ T }$. We will take the <b>rounding strategy</b>. We will round process time of each job ${ j }$ as ${ \lfloor \frac{p_j}{\mu} \rfloor}$, so each process time is a multiple of ${ \mu }$, it’s more easy to apply Dynamic Programming. And we also prove that <b>if</b> we can schedule these rounding jobs with ${ (1+\epsilon) }$-approximation, then the scheduling plan is <b>still ${ (1+\epsilon) }$-approximation</b> for original jobs.</p> </li> <li> <p>Then, we will design the <b>Dynamic Programming</b> algorithm for rounding jobs and prove it can be done in polynomial time.</p> </li> </ol> <h1 id="long-and-short-jobs">Long and short jobs</h1> <p>We can choose some ${ T^* }$ such that ${ T^* \leq OPT }$. We define a job as long job if ${ p_j \geq \epsilon T^* }$, otherwise it is a short job.</p> <p>Suppose we have an algorithm that can schedule long jobs within ${ (1+\epsilon)OPT }$. We can get following PTAS</p> <ul> <li> <p>Step 1: Use “oracle” to schedule long jobs.</p> </li> <li> <p>Step 2: Add the short jobs one by one, each time placing the job on the least loaded machine.</p> </li> </ul> <h2 id="aproximation-analysis">aproximation analysis</h2> <p><b>Lemma 1</b>：The PTAS gives a sechedule of length ${ C_{max} = (1+\epsilon)OPT }$.</p> <p>Proof. Let ${ \ell }$ be the job that finishes last in the schedule</p> <ul> <li> <p>Case 1: Job ${ \ell }$ is a long job. Then, the makespan doesn’t change after adding short jobs. So, ${ C_{max} = (1+\epsilon)OPT }$.</p> </li> <li> <p>Case 2: Job ${ \ell }$ is a long job. Let ${ S_{\ell} }$ be the start time of job ${ \ell }$. Because, all machines have load at least ${ S_{\ell} }$ (By step2, we place the job on the least loaded machine). Hence, ${ S_{\ell} }$ must be not greater than average process time, that is ${ S_{\ell} \leq \sum_{j \neq \ell} p_j /m \leq \sum_{j} p_j /m }$. And we know the optimal makespan can not be less than average process time. Denote ${ P = \sum_{j} p_j }$, we get</p> </li> </ul> <center>$$ S_{\ell} \leq \frac{P}{m} \leq OPT $$</center> <p>Thus, we get</p> <center>$$ C_{max} = S_{\ell} + p_{\ell} \leq OPT + p_{\ell} \leq OPT + \epsilon T^* \leq OPT + \epsilon OPT = (1+\epsilon) OPT $$</center> <p>We prove lemma 1. ${ \square }$</p> <h2 id="runing-time-analysis">Runing time analysis</h2> <p>It’s clear Step 2 can be done in polynomial time. We will show, by selecting appropriate ${ T^* }$ and assuming ${ m }$ is constant, we can finish Step 1 in polynomial time.</p> <p><b>Lemma 2</b>: If ${ T^* = \frac{P}{m}}$, then an optimal schedule of the long jobs can be found in ${ O(m^{m/\epsilon}) }$ time.</p> <p>Proof. We noticed that the number of long jobs is no more than ${ \frac{P}{\epsilon T^*} = P / \left(\epsilon \frac{P}{m}\right) = \frac{m}{\epsilon} }$. Each long job have ${ m }$ choices, so we can try all posible schedule in ${ O(m^{m/\epsilon}) }$ time. ${ \square }$</p> <h1 id="relaxed-decision-procedure">Relaxed decision procedure</h1> <p>In the next part, we will give an algorithm ${ \mathcal{B}_{\epsilon} }$, that takes a time ${ T }$ as input. And algorithm ${ \mathcal{B}_{\epsilon} }$ either prove that no schedule of length ${ T }$, or else find a schedule of length ${ (1+\epsilon)T }$. Suppose we have the above algorithm, we will show how we can employ ${ \mathcal{B}_{\epsilon} }$ to solve the original problem.</p> <h2 id="bisection-search">Bisection Search</h2> <p><b>Here, we ask all the process times are integer.</b> First we give the lower and upper bound of ${ OPT }$.</p> <center>$$ L_0 = \max \left\{ \Bigl\lceil \sum_{j=1}^n p_j / m \Bigr\rceil, \max_{j=1,\cdots,n}p_j \right\} $$</center> <center>$$ U_0 = \Bigl\lceil \sum_{j=1}^n p_j / m \Bigr\rceil+ \max_{j=1,\cdots,n}p_j $$</center> <p>Note ${ L_0, U_0 }$ gets from <a href="https://wu-haonan.github.io/2023/10/23/ADA_Lec_18.html">pervious blog</a> (${ OPT }$ makespan must be not less than max process time and average time on ${ m }$ machines. The upper bound can be get by considering the last complete job, which less and equal to average time plus max process time.) Through out the bisection search, we maintain two invariants (1) lower bound ${ L \leq OPT }$, and (2) compute a schedule with makespan at most ${ (1+\epsilon)U }$.</p> <p>In each iteration, the current interval is ${ [L,U] }$, we set ${ T=\lfloor (L+U)/2\rfloor }$, and run ${ \mathcal{B}_{\epsilon} }$.</p> <ol> <li> <p>If ${ \mathcal{B}_{\epsilon} }$ produces a schedule, then update ${ U \leftarrow T }$</p> </li> <li> <p>Otherwise, ${ L \leftarrow T + 1 }$.</p> </li> </ol> <p>The ${ \mathcal{B}_{\epsilon} }$ terminates untill ${ L =U }$.</p> <p>It’s clear to check in each iteration, two variants are keeping correct. And we know the difference between ${ L_0 }$ and ${ U_0 }$ is at most ${\max_{j=1,\cdots,n}p_j }$, denoted as ${ P_m }$. So ${ \mathcal{B}_{\epsilon} }$ stops in ${ O(\ln P_m) }$ steps.</p> <p>And, we know ${ L = U \leq OPT}$, and ${ \mathcal{B}_{\epsilon} }$ output schedule with makespan ${ (1+\epsilon)U = (1+\epsilon)L \leq OPT }$.</p> <h1 id="rounding-long-jobs">Rounding long jobs</h1> <p>Now we will give the algorithm ${ \mathcal{B}_{\epsilon} }$. First, we need to round the data and apply Dynamic Programming to solve the rounded data. In this section, we will show how to round and prove the approximation.</p> <p>Let ${ \mu = \epsilon^2 T }$; Round the process time of each long job ${ j}$ as ${ p_j’ = \lfloor \frac{p_j}{\mu} \rfloor \mu }$</p> <p><b> Lemma 3</b>: If ${ T \geq OPT }$, and Dynamic Programming can give a schedule on rounded jobs in target time ${ T }$. ${ \mathcal{B}_{\epsilon} }$ will give an ${ (1+\epsilon)T }$ schedule.</p> <p>Proof. For each job ${ j }$, the difference of ${ p_j }$ and ${ p_j’ }$ bounded by</p> <center>$$ p_j - p_j' = p_j - \Bigl\lfloor \frac{p_j}{\mu} \Bigr\rfloor \mu \leq \mu= \epsilon^2 T $$</center> <p>When Dynamic Programming gives schedule on rounded jobs, we directly use the schedule for original jobs. Because we only consider long job here, so we have ${ p_j \geq \epsilon T }$ by definition. And the makespan at most ${ T }$ for each machine, so there at most ${ \frac{T }{p_j} \leq \frac{T}{\epsilon T} = \frac{1}{\epsilon} }$ jobs.</p> <p>Hence, we increase the process time per machine at most ${\frac{1}{\epsilon} \cdot \epsilon^2 T = \epsilon T}$, that means the total length of schedule of original jobs is ${ (1+\epsilon)T }$ approximation. ${ \square }$</p> <h1 id="dynamic-programming-of-rounded-long-jobs">Dynamic Programming of rounded long jobs</h1> <p>Then all the process times of rounded jobs are multiple of ${ \mu }$ and let the largest be ${ r \mu }$.</p> <p>We sat a job is of type ${ i }$ if its rounded time is ${ i \mu }$.</p> <p>We define a vector ${ (n_1,n_2,\cdots,n_r) }$ represents a set of jobs where each ${ n_i }$ is the number of jobs of type ${ i }$.</p> <p>Let ${ \mathcal{C} }$ denote the set of all possible vectors for which the total rounded processing time is at most ${ T }$, i.e., the set of jobs represented by vector in ${ \mathcal{C} }$ can be completed in ${ T }$ in one machine.</p> <p>Denoted the vector of rounded instance is ${ (\hat{n_1},\hat{n_2},\cdots,\hat{n_r}) }$.</p> <p>We define the subproblem of DP as ${ F_k(n_1,n_2,\cdots,n_r) }$, that returns True or False, meaning if we can schedule instance ${ (n_1,n_2,\cdots,n_r) }$ on ${ k }$ machine in time ${ T }$.</p> <p>The state transition equation is: ${ F_k(n_1,n_2,\cdots,n_r) = \text{TRUE} }$ if and only if</p> <ol> <li> <p>${ (n_1,n_2,\cdots,n_r) \in \mathcal{C} }$ or</p> </li> <li> <p><b>There exists</b> ${ (s_1,s_2,\cdots,s_r) \in \mathcal{C} }$, such that ${ F_k(n_1-s_1,n_2-s_2,\cdots,n_r-s_r) = \text{TRUE} }$</p> </li> </ol> <p>And finnaly we need to compute ${ F_m(\hat{n_1},\hat{n_2},\cdots,\hat{n_r}) }$. Additionally, retrieve the corresponding schedule in the DP, we can return the schedule for all long rounded jobs.</p> <h2 id="run-time-in-polynomial">Run-time in Polynomial</h2> <p>We need to prove the total running time is in polynomial time by showing the number of iterations in DP is in polynomial time and each iteration consumes in polynomial time. The key points are proving ${ \vert \mathcal{C} \vert }$ and ${ r }$</p> <p><b>Claim 1</b>: ${ r }$ is a constant</p> <p>Proof. Let ${ p_m = \max_j p_j }$. As ${ P_m \leq OPT \leq T }$. So the largest rounded processing time is ${ \Bigl\lfloor \frac{p_m}{\mu} \Bigr\rfloor \mu \leq \Bigl\lfloor \frac{T}{\mu} \Bigr\rfloor \mu }$. So ${r= \Bigl\lfloor \frac{T}{\mu} \Bigr\rfloor \leq \frac{T}{\mu} = \frac{T}{\epsilon^2 T} = \frac{1}{\epsilon^2} }$ is a constant. ${ \square }$</p> <p><b>Claim 2</b>: The number of rounded jobs per machine is a constant.</p> <p>Proof. From previous discussion, we already prove that there is at most ${ \frac{T }{p_j} \leq \frac{T}{\epsilon T} = \frac{1}{\epsilon} }$ jobs. ${ \square }$</p> <p><b>Claim 3</b>: ${ \vert \mathcal{C} \vert }$ is a constant.</p> <p>Proof. One machine can only have ${ \frac{1}{\epsilon} }$ jobs, so ${ \forall (n_1,n_2,\cdots,n_r) \in \mathcal{C} }$, ${ n_1,n_2,\cdots,n_r \leq \frac{1}{\epsilon} }$, and ${ r }$ is constant. So, ${ \vert \mathcal{C} \vert }$ is a constant. ${ \square }$</p> <p><b>Claim 4</b>: Number of iterations in DP is polynomial.</p> <p>Proof. One machine can only have ${ \frac{1}{\epsilon} }$ jobs, so the total long jobs can not greater that ${ \frac{m}{\epsilon} }$. Hence, ${ \hat{n_i} \leq \frac{m}{\epsilon} }$. So Number of iterations in DP is at most ${ m \left(\frac{m}{\epsilon}\right)^r \leq m \left(\frac{m}{\epsilon}\right)^{1 /\epsilon^2} }$. ${ \square }$</p> <p>So, it’s clear that total running time of DP is in polynomial time.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/ADA_Lec_21/">Rounding and Dynamic Programming:Parallel Machines Job Scheduling</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/ADA_Lec_18/">Gready Alg and Local Search:Parallel Macines Job Scheduling</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/ADA_Lec_8/">Polynimial Reduction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/ADA_Lec_19/">Gready Alg and Local Search:Minimum-Degree Spanning Tree</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/ADA_Lec_9/">NP, NP-Complete Problems</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Haonan Wu (吴昊楠). Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>